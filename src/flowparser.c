/*
 * Each file must start with this include.
 * File containes global settings.
 */
#include "settings.h"

/*
 * Main includes here.
 */
#include "flowparser.h"

/*
 * This file is autogenerated.
 * Changes made to this file can be overwritten.
 */

/*
 * Other includes here.
 */
#include <string.h>     // Required for memcpy()
#include "atomicrun.h"
#include "commands.h"   // Protocol definitions
#include "handlers.h"
#include "macro.h"
#include "algorithm.h"  // Required for CRC16

#if defined(__cplusplus)
extern "C"
{
#endif

typedef struct
{
  union
  {
    uint8_t Array[_PACKET_LENGTH];
    struct
    {
      uint32_t  Command;
      uint8_t   Data[_PACKET_LENGTH - _COMMAND_LENGTH];
    };
  };
  uint16_t Size;

} packet_t;

static void ParsePacketPreparePacket(const packet_t *Input, packet_t *Output);

/*
 * This function gets a command-packet structure
 * and puts into response command-packet.
 * The Array size must be enough to hold any single response.
 */
static void ParsePacketPreparePacket(const packet_t *Input, packet_t *Output)
{
  uint16_t crc;   // This value will contain the packet CRC16 code to verify its data

  /*
   * Each transmit starts with command code. Just copy...
   * After that find packet size in table and paste to the structure.
   */
  Output->Command = Input->Command;
  Output->Size = Commands_GetOutputSize(Output->Command);

  /*
   * Check ERRC state. Checking is based on the return
   * value of the function Commands_GetOutputSize(...).
   * See description Commands_GetOutputSize(...) for more information.
   */
  if (Output->Size == 0)
  {
    Output->Command = ERRC_CMD;
    Output->Size = _COMMAND_LENGTH;
    return;
  }

  /*
   * Check ERRD state.
   */
  if (Input->Size > _COMMAND_LENGTH)  // If there is some data
  {
#ifdef DEBUG
    if (Input->Size <= _COMMAND_LENGTH + _CRC_LENGTH)   // Detect generation error
    {
      while (1)
      {
        // Capture
      }
    }
#endif  // DEBUG

    uint16_t InputFieldsSize = Input->Size - _COMMAND_LENGTH - _CRC_LENGTH;

    /*
     * Using as CRC16 2 bytes from the end of packet (after input fields).
     */
    crc = HWREGH(Input->Data + InputFieldsSize);

    /*
     * Calc and check CRC16.
     */
    if (crc != crc16(Input->Data, InputFieldsSize))
    {
      Output->Command = ERRD_CMD;
      Output->Size = _COMMAND_LENGTH;
      return;
    }
  }

  /*
   * If in the end errv is non zero, it means that a value
   * came out of the range and has been corrected.
   */
  int32_t errv = 0;



  switch (Input->Command)
  {
    /*
     * Regular commands with input data must be below
     */
  case WKEY_CMD:
    {
      in_write_key_t original;
      in_write_key_t duplicate;
      out_write_key_t output;

      memcpy(&original, Input->Data, sizeof(original));
      memcpy(&duplicate, Input->Data, sizeof(duplicate));

      on_write_key(&duplicate, &output);

      errv |= memcmp(&original, &duplicate, sizeof(original));

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case CONN_CMD:
    {
      in_start_session_t original;
      in_start_session_t duplicate;
      out_start_session_t output;

      memcpy(&original, Input->Data, sizeof(original));
      memcpy(&duplicate, Input->Data, sizeof(duplicate));

      on_start_session(&duplicate, &output);

      errv |= memcmp(&original, &duplicate, sizeof(original));

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case DISC_CMD:
    {
      in_end_session_t original;
      in_end_session_t duplicate;
      out_end_session_t output;

      memcpy(&original, Input->Data, sizeof(original));
      memcpy(&duplicate, Input->Data, sizeof(duplicate));

      on_end_session(&duplicate, &output);

      errv |= memcmp(&original, &duplicate, sizeof(original));

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case WDAT_CMD:
    {
      write_data_t original;
      write_data_t duplicate;

      memcpy(&original, Input->Data, sizeof(original));
      memcpy(&duplicate, Input->Data, sizeof(duplicate));

      on_write_data(&duplicate);

      errv |= memcmp(&original, &duplicate, sizeof(original));
    }
    break;

  case SSER_CMD:
    {
      set_serial_number_t original;
      set_serial_number_t duplicate;

      memcpy(&original, Input->Data, sizeof(original));
      memcpy(&duplicate, Input->Data, sizeof(duplicate));

      on_set_serial_number(&duplicate);

      errv |= memcmp(&original, &duplicate, sizeof(original));
    }
    break;

    /*
     * Accessors like S*** must be below
     */
  case SDMY_CMD:
    {
      dummy_t original;
      dummy_t duplicate;

      memcpy(&original, Input->Data, sizeof(original));
      memcpy(&duplicate, Input->Data, sizeof(duplicate));

      on_set_dummy(&duplicate);

      errv |= memcmp(&original, &duplicate, sizeof(original));

      ATOMIC_RUN(memcpy(&Commands_SettingsStorage.DMY, &duplicate, sizeof(duplicate)));
    }
    break;

    /*
     * Regular commands without input data must be below.
     */
  case REST_CMD:
    {
      on_reset();
    }
    break;

  case GETI_CMD:
    {
      get_device_information_t output;
      on_get_device_information(&output);

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case GBLV_CMD:
    {
      get_bootloader_version_t output;
      on_get_bootloader_version(&output);

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case HASF_CMD:
    {
      has_firmware_t output;
      on_has_firmware(&output);

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case GOFW_CMD:
    {
      goto_firmware_t output;
      on_goto_firmware(&output);

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case IRND_CMD:
    {
      init_random_t output;
      on_init_random(&output);

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case GSER_CMD:
    {
      get_serial_number_t output;
      on_get_serial_number(&output);

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case UPDF_CMD:
    {
      on_update_firmware();
    }
    break;

  case GETS_CMD:
    {
      get_status_t output;
      on_get_status(&output);

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case GINF_CMD:
    {
      get_identity_information_t output;
      on_get_identity_information(&output);

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    }
    break;

  case RBLD_CMD:
    {
      on_reboot_to_bootloader();
    }
    break;

    /*
     * Accessors like G*** must be below
     */
  case GDMY_CMD:
    {
      ATOMIC_RUN(memcpy(Output->Data, &Commands_SettingsStorage.DMY, sizeof(Commands_SettingsStorage.DMY)));
    }
    break;

#ifdef DEBUG
  default:  // Detect generation error
    while (1)
    {
      // Capture
    }
#endif  // DEBUG
  }

  /*
   * Check ERRV state.
   */
  if (errv)
  {
    Output->Command = ERRV_CMD;
    Output->Size = _COMMAND_LENGTH;
    return;
  }

  if (Output->Size > _COMMAND_LENGTH)   // If data was added
  {
#ifdef DEBUG
    if (Output->Size <= _COMMAND_LENGTH + _CRC_LENGTH)  // Detect generation error
    {
      while (1)
      {
        // Capture
      }
    }
#endif  // DEBUG

    uint16_t OutputFieldsSize = Output->Size - _COMMAND_LENGTH - _CRC_LENGTH;

    /*
     * Using as CRC16 2 bytes at the end of packet (after output fields).
     * Calculate CRC16 and paste.
     */
    HWREGH(Output->Data + OutputFieldsSize) = crc16(Output->Data, OutputFieldsSize);
  }

  return;
}

/*
 * This function handles protocol parsing and protocol response between controlling unit and the device
 * A fully received command is searched for in incoming cycle buffer. Whence found, it is processed with GetData()
 * the return value describes whether a command has been processed
 * It also handles synchronization zeroes logic.
 */
uint16_t FlowParser_Process(io_buffer_t *pRxBuf, io_buffer_t *pTxBuf)
{
  static packet_t ReadPacket;   // Packet under examination

  packet_t WritePacket;         // Packet to store the response
  uint16_t retval = 0;          // Return value (number of new bytes to send)

  // First we look whether we have previous knowledge about command length
  if (ReadPacket.Size == 0) // Length is zero - check for command
  {
    /*
     * If first symbol is '\0' then we must echo
     * and discard it (the same for each next byte)
     */
    while (IOBuffer_Size(pRxBuf))   // While there are symbols in the input buffer
    {
      uint8_t FirstByte;

      IOBuffer_PeekC(pRxBuf, &FirstByte);   // Look at first byte

      /*
       * If byte is a command byte - exit cycle
       * and proceed to command recognition
       */
      if (FirstByte)
      {
        break;  // Quit the cycle
      }

      /*
       * Otherwise load zero byte from buffer
       * and prepare to send it
       */
      IOBuffer_GetC(pRxBuf, &FirstByte);
      IOBuffer_PutC(pTxBuf, FirstByte);

      retval++;   // One more byte to send
    }

    /*
     * Now first byte is not zero
     * and must be the first symbol of a command
     */
    if (IOBuffer_Size(pRxBuf) < _COMMAND_LENGTH)  // Command not received yet
      return retval;  // Return and wait for missing bytes

    /*
     * We have a command.
     * Proceed...
     */
    IOBuffer_GetBuf(pRxBuf, ReadPacket.Array, _COMMAND_LENGTH);   // Transfer bytes from cycle buffer to packet structure
    ReadPacket.Size = Commands_GetInputSize(ReadPacket.Command);  // Get additional data size
  }

  /*
   * At this stage we know our command and its size
   */
  if (ReadPacket.Size)  // If there is any additional data to receive. (Not else)
  {
    uint16_t DataSize = ReadPacket.Size - _COMMAND_LENGTH;

    if (IOBuffer_Size(pRxBuf) < DataSize)   // If not enough additional data
      return retval;  // Quit and wait for more data

#ifdef DEBUG
    if (IOBuffer_GetBuf(pRxBuf, ReadPacket.Data, DataSize) != true)   // Detect generation error
      while (1)
      {
        // Capture
      }
#else
    IOBuffer_GetBuf(pRxBuf, ReadPacket.Data, DataSize);   // Transfer data to packet structure.
#endif  // DEBUG
  }

  /*
   * At this stage we have a packet with command
   * with possible additional data. Beginning processing.
   */
  ParsePacketPreparePacket(&ReadPacket, &WritePacket);  // Process command

  IOBuffer_PutBuf(pTxBuf, WritePacket.Array, WritePacket.Size);   // Copy response to output buffer

  ReadPacket.Size = 0;  // Reinit command sequence

  return retval + WritePacket.Size;
}

#if defined(__cplusplus)
};
#endif
